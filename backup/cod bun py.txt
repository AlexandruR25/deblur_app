"""
Proiect Licență: Înlăturarea defocalizării din imagini cu rețele neuronale profunde
Autor: [Numele Tău]
Coordonator: [Nume Profesor]
"""

import os
import cv2
import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
import matplotlib.pyplot as plt
from torch.utils.data import Dataset, DataLoader

# Configurație implicită
DEFAULT_CONFIG = {
    "train_dir": "data/train",
    "val_dir": "data/val",
    "model_save_dir": "models",
    "results_dir": "results",
    "default_epochs": 5,
    "default_batch_size": 8,
    "default_model_path": "models/best_model.pth",
    "save_every_epoch": False
}

class DefocusDataset(Dataset):
    """Set de date pentru antrenare cu detectare automată a structurii"""
    def __init__(self, blur_dir, sharp_dir):
        self.blur_paths = sorted([os.path.join(blur_dir, f) for f in os.listdir(blur_dir)])
        self.sharp_paths = sorted([os.path.join(sharp_dir, f) for f in os.listdir(sharp_dir)])

    def __len__(self):
        return min(len(self.blur_paths), len(self.sharp_paths))

    def __getitem__(self, idx):
        blur = cv2.imread(self.blur_paths[idx]).astype(np.float32) / 255.0
        sharp = cv2.imread(self.sharp_paths[idx]).astype(np.float32) / 255.0
        return (
            torch.from_numpy(blur).permute(2,0,1),
            torch.from_numpy(sharp).permute(2,0,1)
        )

class AutoDeblurUNet(nn.Module):
    """Arhitectură U-Net avansată cu blocuri reziduale"""
    def __init__(self):
        super().__init__()
        
        # Encoder
        self.enc1 = nn.Sequential(
            nn.Conv2d(3, 64, 3, padding=1),
            nn.ReLU(),
            nn.BatchNorm2d(64),
            nn.Conv2d(64, 64, 3, padding=1),
            nn.ReLU()
        )
        self.pool = nn.MaxPool2d(2)
        
        self.enc2 = nn.Sequential(
            nn.Conv2d(64, 128, 3, padding=1),
            nn.ReLU(),
            nn.BatchNorm2d(128),
            nn.Conv2d(128, 128, 3, padding=1),
            nn.ReLU()
        )
        
        # Bottleneck
        self.bottleneck = nn.Sequential(
            nn.Conv2d(128, 256, 3, padding=1),
            nn.ReLU(),
            nn.BatchNorm2d(256),
            nn.Conv2d(256, 256, 3, padding=1),
            nn.ReLU()
        )
        
        # Decoder
        self.up1 = nn.ConvTranspose2d(256, 128, 2, stride=2)
        self.dec1 = nn.Sequential(
            nn.Conv2d(256, 128, 3, padding=1),
            nn.ReLU(),
            nn.BatchNorm2d(128),
            nn.Conv2d(128, 128, 3, padding=1),
            nn.ReLU()
        )
        
        self.up2 = nn.ConvTranspose2d(128, 64, 2, stride=2)
        self.dec2 = nn.Sequential(
            nn.Conv2d(128, 64, 3, padding=1),
            nn.ReLU(),
            nn.BatchNorm2d(64),
            nn.Conv2d(64, 64, 3, padding=1),
            nn.ReLU()
        )
        
        self.final = nn.Conv2d(64, 3, 1)

    def forward(self, x):
        # Encoder
        e1 = self.enc1(x)
        p1 = self.pool(e1)
        
        e2 = self.enc2(p1)
        p2 = self.pool(e2)
        
        # Bottleneck
        b = self.bottleneck(p2)
        
        # Decoder
        u1 = self.up1(b)
        c1 = torch.cat([u1, e2], dim=1)
        d1 = self.dec1(c1)
        
        u2 = self.up2(d1)
        c2 = torch.cat([u2, e1], dim=1)
        d2 = self.dec2(c2)
        
        return self.final(d2)

def automated_trainer():
    """Antrenare automată cu parametri predefiniți"""
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    print(f"Dispozitiv utilizat: {device}")
    
    # Verificare structură directoare
    os.makedirs(DEFAULT_CONFIG["model_save_dir"], exist_ok=True)
    
    # Inițializare dataset și loader
    train_dataset = DefocusDataset(
        os.path.join(DEFAULT_CONFIG["train_dir"], "blur"),
        os.path.join(DEFAULT_CONFIG["train_dir"], "sharp")
    )
    train_loader = DataLoader(
        train_dataset,
        batch_size=DEFAULT_CONFIG["default_batch_size"],
        shuffle=True
    )
    
    # Inițializare model și optimizator
    model = AutoDeblurUNet().to(device)
    optimizer = optim.Adam(model.parameters(), lr=0.001)
    criterion = nn.L1Loss()
    
    best_loss = float('inf')
    
    # Buclă antrenare
    for epoch in range(DEFAULT_CONFIG["default_epochs"]):
        model.train()
        total_loss = 0.0
        
        for blur, sharp in train_loader:
            blur, sharp = blur.to(device), sharp.to(device)
            
            optimizer.zero_grad()
            outputs = model(blur)
            loss = criterion(outputs, sharp)
            loss.backward()
            optimizer.step()
            
            total_loss += loss.item()
        
        # Calcul loss mediu
        avg_loss = total_loss / len(train_loader)
        
        # Salvare model optim
        if avg_loss < best_loss:
            best_loss = avg_loss
            torch.save(model.state_dict(), DEFAULT_CONFIG["default_model_path"])
            print(f"Model salvat la: {DEFAULT_CONFIG['default_model_path']}")
        
        print(f"Epoca {epoch+1}/{DEFAULT_CONFIG['default_epochs']} | Loss: {avg_loss:.4f}")

def automated_processor():
    """Procesare automată a imaginilor de test"""
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model = AutoDeblurUNet().to(device)
    
    try:
        model.load_state_dict(torch.load(DEFAULT_CONFIG["default_model_path"], map_location=device))
    except FileNotFoundError:
        print("Eroare: Model preantrenat nu există! Rulați mai întâi antrenarea (opțiunea 1).")
        return
    
    # Procesare imagini test
    test_dir = "data/test/blur"
    os.makedirs(DEFAULT_CONFIG["results_dir"], exist_ok=True)
    
    for img_file in os.listdir(test_dir):
        img_path = os.path.join(test_dir, img_file)
        img = cv2.imread(img_path).astype(np.float32) / 255.0
        img_tensor = torch.from_numpy(img).permute(2,0,1).unsqueeze(0).to(device)
        
        with torch.no_grad():
            output = model(img_tensor)
        
        output_img = output.squeeze().permute(1,2,0).cpu().numpy() * 255
        cv2.imwrite(os.path.join(DEFAULT_CONFIG["results_dir"], f"deblurred_{img_file}"), output_img)
               
        


if __name__ == "__main__":
    print("""
    ======================================
    Sistem Autonom Deblurring Defocus
    ======================================
    1. Antrenare model
    2. Procesare imagini test
    3. Ieșire
    """)
    
    while True:
        choice = input("Alege operațiunea (1-3): ")
        
        if choice == "1":
            print("\nInițializare antrenare cu parametri default:")
            print(f"Epoci: {DEFAULT_CONFIG['default_epochs']}")
            print(f"Batch size: {DEFAULT_CONFIG['default_batch_size']}")
            print(f"Director antrenare: {DEFAULT_CONFIG['train_dir']}")
            automated_trainer()
        elif choice == "2":
            print("\nProcesare automată a imaginilor din data/test/blur")
            automated_processor()
        elif choice == "3":
            print("La revedere!")
            break
        else:
            print("Opțiune invalidă! Introduceți 1, 2 sau 3.")
